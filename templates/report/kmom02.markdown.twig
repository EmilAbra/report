Kmom02
-------
**Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.**

**Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?**

**Vilken är din TIL för detta kmom?**

Ett arv innebär att en klass ärver alla medlemsvariabler och metoder från en annan klass. Förhållandet blir då förälder och barn, eller bas- och subklass. För att aktivera arvet i PHP använder man nyckelordet "extends" efter deklarationen av subklassen följt av basklassens namn. En subklass som ärver från basklassen kan skriva över de ärvda metoderna eller medlemsvariablerna genom att man skriver samma namn som är deklarerad i basklassen.

Komposition i objektorienterad programmering innebär att två objekt har stark koppling till varandra. En klass objekt som består av en annan klass objekt kan inte existera ensamt om den ena försvinner. En svagare koppling kallas aggregat och då kan kopplingen brytas och de kan ändå fungera på egen hand. I PHP deklarerar man den andra klassens objekt inuti klassen och det kan göras på olika vis. Man kan till exempel anropa ett objekt i någon metods argument eller direkt in i konstruktorn. Man bör med fördel "injecta" objekt in till klassen utanför klassens "scope" genom metodernas argument för att tillföra dem. Det underlättar när man sedan ska jobba med felhanteringen.

Ett interface är ett löfte om att en klass ska innehålla metoder som deklareras i interfacet. Det gör att man får bättre översyn över klassen som implementerar interfacet. Alla objekt som använder det kan omväxlande användas på ett smidigare sätt då man vet att de har samma metoder. I PHP deklareras interfacet som en klass men med nyckelordet "interface" istället för "class". Metoderna i interfacet skrivs som en vanlig metod förutom att man inte anger metodens body, endast dess namn. För att deklarera att klassen använder sig av interfacet använder man nyckelordet "implements" och interfacets namn efter deklarationen av klassen.

Ibland kan flera klasser innehålla samma metoder och medlemsvariabler. Istället för att upprepa koden i dessa klasser kan man använda ett trait. Det kan då jämföras med en modul som kan återanvändas och kopieras in i klassens body. Ändrar man något i traitet ändrar man också i samtliga klasser som implementerar traitet. Ett trait i PHP deklareras som man deklarerar en klass men istället för "class" använder man "trait".
I klassen deklarerar man att man använder ett trait genom att använda "use" och traitets namn.

För att komma igång med uppgiften började jag med att studera de olika exemplen med klasser i exempelmappen. Som en grund insåg jag att jag i någon utav klasserna Deck och Card behövde hämta värden och färger på kortleken. Det föll mig då logiskt att skilja på de två kategorierna och att använda två arrays genom att placera dem som konstanta medlemsvariabler i klassen Deck. Jag tänkte att kortleken i Deck kunde vara tom från början i konstruktorn och genom metoder hämta värdena i samband med att korten i Card skapas. Det gör att korten "injectas" in i kortleken istället för att vara fast bundna till kortleken. Det löste jag med att i Controllern för kortleken använda mig av nästlade foreach-loopar som först går igenom varje färg av de fyra olika och tillsätter dem alla värden. Jag valde därför att låta klassen Card vara enkelt uppbyggd och tar endast emot färg och värde i konstruktorn när de skapas och tillsätts till kortleken. Det gör att man också kan välja antalet kort som kortleken ska innehålla.

Det mesta sköts av klassen Deck och dess metoder. Jag använde olika array-metoder i metoderna för klassen, för att blanda, dra kort och räkna kortleken. De anropadas i Controllerna efter att korten har tillsatts. De olika värdena som hämtas från metoderna tillsätts till variabler och placeras i arrayen "data" som skickas med i renderingen till templaten. På nätet hittade jag "CSS Playing Cards" för att få designen på spelkorten i CSS.

I template-mappen gjorde jag en ny mapp "card" som innehåller alla vyer för uppgiften. Det kändes som att det behövdes då det annars blev många filer på en och samma ställe. Jag använde mig av kodsnuttar som återanvändes, som exempelvis navbaren för alla kort-val, i egna filer och använde Twigs include för att hämta filens innehåll till varje sida. Det gjorde att jag inte behövde skriva lika mycket kod och det blev tydligare struktur.

I uppgifterna med sessioner hämtade jag mycket kunskap från exempel-filerna och använde "get" och "set"-metoderna för att uppdatera sessionen. I routen för att blanda kortleken skapar jag en ny kortlek och sedan sätter den i sessionen. Det gör att kortleken blir fullständig igen.

I uppgiften med korleken som ett Json-objekt läste jag på om det på Symfonys hemsida och använde Serialize och JsonEncoder för att formatera om kortlekens objekt, och ett nytt objekt av JsonResponse för svaret. Utskriften blev inte alls snygg, så jag läste om setEncodingOptions som kan hämta en snyggare utskrift med "pretty print", som jag använde.

Som klasser i uppgiften med antal spelare och antal kort per spelare skapade jag två separata klasser för Cardhand och Player. Det enda de gör är att avskilja varje spelare. Player har ett objekt av Cardhand. Cardhand tillförs ett objekt av Deck med alla korten. Varje Player-objekt tillförs till arrayen data som skickas med i renderingen. Det blir då som en rysk docka med nästlade objekt och arrayer i flera nivåer. Det jag hade svårt med var att skriva ut varje kort för varje spelare efter att de skickas med templaten för "draw_with_players". Jag försökte på många vis med nästlade foreach-loopar för att traversera både objekt och array, men fick ingen utskrift. Tillslut hittade jag bra sida på "stackowerflow" som översiktligt beskriver nästlade arrayer.

Det var svårt att komma på en bra struktur på både objekt och routes. Jag lyckades få till sidan "deal" så att användaren kan skriva i url:en antal spelare och antal kort. Men jag kände att det inte blev så snyggt med endast rubrik och att användaren endast kan välja genom url:en. Jag valde därför att lägga till ett formulär för användaren att fylla i. Formuläret skapades med metoden POST och jag hämtade värdena i processingsidan för samma route med hjälp av Request-objekt och get-metoder. Det var en del trix att få till "redirecten" till resultatsidan med värdena. Det blev många felmeddelande innan jag upptäckte att jag hade glömt att byta namn på routen för processingsidan som var samma som formulär-sidan.

Jag tycker att jag är mest nöjd med att jag fick till uppgiften med spelare och att användaren kan använda ett formulär. Det finns klart förbättringar med logiken att göra då en spelare inte kan välja för lite kort och spelare och inte heller för många kort så att korleken tar slut. Även med designen och css-koden finns en del att pilla med. Men jag nöjer mig så och lämnar det till kommande kmoms.

Jag tycker att jag lärde mig mycket om hur det fungerar när man itererar över en array med nästlade arrayer och objekt. För att skriva ut innehållet i objekt och deras medlemsvariabler använder man dotnotationer i Twig. Är variabeln privat letar Twig upp "getmetoden" för variabeln automatiskt i klassen. Finns en till array efter ett objekt krävs nästlade foreach-loopar för att traversera djupare i iterationen. Det får vara min TIL för detta kmom.
